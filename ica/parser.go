package ica

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

type autoGeneratedCustomer struct {
	CustomerNumber int `json:"CustomerNumber"`
	Cards          []struct {
		Accounts []struct {
			Balance       string `json:"Balance"`
			Available     string `json:"Available"`
			AccountType   string `json:"AccountType"`
			AccountName   string `json:"AccountName"`
			AccountStatus string `json:"AccountStatus"`
		} `json:"Accounts"`
		CardTypeDescription string `json:"CardTypeDescription"`
		CardTypeCode        string `json:"CardTypeCode"`
		MaskedCardNumber    string `json:"MaskedCardNumber"`
		Selected            bool   `json:"Selected"`
	} `json:"Cards"`
}
type autoGeneratedTransactions struct {
	TransactionSummaryByMonth []struct {
		Year                 string `json:"Year"`
		Month                string `json:"Month"`
		YearMonthAsDateTime  string `json:"YearMonthAsDateTime"`
		TransactionForAMonth []struct {
			TransactionDate  string  `json:"TransactionDate"`
			MarketingName    string  `json:"MarketingName"`
			TotalDiscount    float64 `json:"TotalDiscount"`
			TransactionValue float64 `json:"TransactionValue"`
		} `json:"TransactionForAMonth"`
	} `json:"TransactionSummaryByMonth"`
}

func parseFloat(data string) (val float64, err error) {
	data = strings.Replace(data, ",", ".", 1)
	f, err := strconv.ParseFloat(data, 64)

	return f, err
}

// ParseAccount parses json for account
func ParseAccount(resp *http.Response, ica *Ica) (*Ica, error) {
	defer resp.Body.Close()
	jsonBlob, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return ica, err
	}
	customer := autoGeneratedCustomer{}
	err = json.Unmarshal(jsonBlob, &customer)
	if err != nil {
		return ica, err
	}

	available, err := parseFloat(customer.Cards[0].Accounts[0].Available)
	if err != nil {
		return ica, err
	}
	ica.Available = available
	balance, err := parseFloat(customer.Cards[0].Accounts[0].Balance)
	if err != nil {
		return ica, err
	}

	ica.Balance = balance

	return ica, nil
}

// ParseTransactions parses transactions
func ParseTransactions(resp *http.Response, ica *Ica) (*Ica, error) {
	var trans []Transaction
	defer resp.Body.Close()
	jsonBlob, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return ica, err
	}
	transactions := autoGeneratedTransactions{}
	err = json.Unmarshal(jsonBlob, &transactions)
	if err != nil {
		return ica, err
	}

	for _, m := range transactions.TransactionSummaryByMonth {
		for _, tr := range m.TransactionForAMonth {
			t := Transaction{}
			date, _ := time.Parse("20060102", tr.TransactionDate)
			t.Date = date
			t.Location = tr.MarketingName
			t.Discount = tr.TotalDiscount
			t.Amount = tr.TransactionValue
			trans = append(trans, t)
		}
	}
	ica.Transactions = trans

	return ica, nil
}

// ParseHTML parses html
func ParseHTML(resp *http.Response, ica *Ica) (*Ica, error) {
	doc, err := goquery.NewDocumentFromResponse(resp)
	// f, _ := os.Open("out.html")
	// doc, err := goquery.NewDocumentFromReader(bufio.NewReader(f))
	if err != nil {
		return ica, err
	}
	var available string
	var balance string
	doc.Find("div[class=\"account-container account-loaded active\"] dd").EachWithBreak(func(i int, s *goquery.Selection) bool {
		// We want the first dd
		if i > 2 {
			return false
		} else if i == 0 {
			available = strings.Replace(s.Text(), ",", ".", 1)
			available = strings.Replace(available, " kr", "", 1)
		} else if i == 2 {
			balance = strings.Replace(s.Text(), ",", ".", 1)
			balance = strings.Replace(balance, " kr", "", 1)
		}
		return true
	})
	amount, err := strconv.ParseFloat(available, 64)
	if err != nil {
		return ica, err
	}
	ica.Available = amount

	bal, err := strconv.ParseFloat(balance, 64)
	if err != nil {
		return ica, err
	}
	ica.Balance = bal

	// Transactions

	doc.Find("section[id=\"transaktioner\"] dl").Each(func(i int, s *goquery.Selection) {
		location := strings.Trim(s.Find("p").Text(), " ")
		date, _ := time.Parse("2006-01-02", s.Find("dt").Text())
		value, _ := parseFloat(s.Find("dd").Text())
		t := Transaction{}
		t.Date = date
		t.Location = location
		t.Discount = 0
		t.Amount = value
		ica.Transactions = append(ica.Transactions, t)

	})

	return ica, nil
}
